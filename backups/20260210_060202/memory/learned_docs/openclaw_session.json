{
  "type": "markdown",
  "source": "/usr/lib/node_modules/openclaw/docs/concepts/session.md",
  "title": "Session Management",
  "description": "> **Security Warning:** If your agent can receive DMs from **multiple people**, you should strongly consider enabling secure DM mode. Without it, all users share the same conversation context, which can leak private information between users.\n\n**Example of the problem with default settings:**\n\n- Alice (`<SENDER_A>`) messages your agent about a private topic (for example, a medical appointment)\n- Bob (`<SENDER_B>`) messages your agent asking \"What were we talking about?\"\n- Because both DMs share ",
  "sections": {
    "Secure DM mode (recommended for multi-user setups)": "> **Security Warning:** If your agent can receive DMs from **multiple people**, you should strongly consider enabling secure DM mode. Without it, all users share the same conversation context, which can leak private information between users.\n\n**Example of the problem with default settings:**\n\n- Alice (`<SENDER_A>`) messages your agent about a private topic (for example, a medical appointment)\n- Bob (`<SENDER_B>`) messages your agent asking \"What were we talking about?\"\n- Because both DMs share the same session, the model may answer Bob using Alice's prior context.\n\n**The fix:** Set `dmScope` to isolate sessions per user:\n\n\n**When to enable this:**\n\n- You have pairing approvals for more than one sender\n- You use a DM allowlist with multiple entries\n- You set `dmPolicy: \"open\"`\n- Multiple phone numbers or accounts can message your agent\n\nNotes:\n\n- Default is `dmScope: \"main\"` for continuity (all DMs share the main session). This is fine for single-user setups.\n- For multi-account inboxes on the same channel, prefer `per-account-channel-peer`.\n- If the same person contacts you on multiple channels, use `session.identityLinks` to collapse their DM sessions into one canonical identity.\n- You can verify your DM settings with `openclaw security audit` (see [security](/cli/security)).",
    "Gateway is the source of truth": "All session state is **owned by the gateway** (the “master” OpenClaw). UI clients (macOS app, WebChat, etc.) must query the gateway for session lists and token counts instead of reading local files.\n\n- In **remote mode**, the session store you care about lives on the remote gateway host, not your Mac.\n- Token counts shown in UIs come from the gateway’s store fields (`inputTokens`, `outputTokens`, `totalTokens`, `contextTokens`). Clients do not parse JSONL transcripts to “fix up” totals.",
    "Where state lives": "- On the **gateway host**:\n  - Store file: `~/.openclaw/agents/<agentId>/sessions/sessions.json` (per agent).\n- Transcripts: `~/.openclaw/agents/<agentId>/sessions/<SessionId>.jsonl` (Telegram topic sessions use `.../<SessionId>-topic-<threadId>.jsonl`).\n- The store is a map `sessionKey -> { sessionId, updatedAt, ... }`. Deleting entries is safe; they are recreated on demand.\n- Group entries may include `displayName`, `channel`, `subject`, `room`, and `space` to label sessions in UIs.\n- Session entries include `origin` metadata (label + routing hints) so UIs can explain where a session came from.\n- OpenClaw does **not** read legacy Pi/Tau session folders.",
    "Session pruning": "OpenClaw trims **old tool results** from the in-memory context right before LLM calls by default.\nThis does **not** rewrite JSONL history. See [/concepts/session-pruning](/concepts/session-pruning).",
    "Pre-compaction memory flush": "When a session nears auto-compaction, OpenClaw can run a **silent memory flush**\nturn that reminds the model to write durable notes to disk. This only runs when\nthe workspace is writable. See [Memory](/concepts/memory) and\n[Compaction](/concepts/compaction).",
    "Mapping transports → session keys": "- Direct chats follow `session.dmScope` (default `main`).\n  - `main`: `agent:<agentId>:<mainKey>` (continuity across devices/channels).\n    - Multiple phone numbers and channels can map to the same agent main key; they act as transports into one conversation.\n  - `per-peer`: `agent:<agentId>:dm:<peerId>`.\n  - `per-channel-peer`: `agent:<agentId>:<channel>:dm:<peerId>`.\n  - `per-account-channel-peer`: `agent:<agentId>:<channel>:<accountId>:dm:<peerId>` (accountId defaults to `default`).\n  - If `session.identityLinks` matches a provider-prefixed peer id (for example `telegram:123`), the canonical key replaces `<peerId>` so the same person shares a session across channels.\n- Group chats isolate state: `agent:<agentId>:<channel>:group:<id>` (rooms/channels use `agent:<agentId>:<channel>:channel:<id>`).\n  - Telegram forum topics append `:topic:<threadId>` to the group id for isolation.\n  - Legacy `group:<id>` keys are still recognized for migration.\n- Inbound contexts may still use `group:<id>`; the channel is inferred from `Provider` and normalized to the canonical `agent:<agentId>:<channel>:group:<id>` form.\n- Other sources:\n  - Cron jobs: `cron:<job.id>`\n  - Webhooks: `hook:<uuid>` (unless explicitly set by the hook)\n  - Node runs: `node-<nodeId>`",
    "Lifecycle": "- Reset policy: sessions are reused until they expire, and expiry is evaluated on the next inbound message.\n- Daily reset: defaults to **4:00 AM local time on the gateway host**. A session is stale once its last update is earlier than the most recent daily reset time.\n- Idle reset (optional): `idleMinutes` adds a sliding idle window. When both daily and idle resets are configured, **whichever expires first** forces a new session.\n- Legacy idle-only: if you set `session.idleMinutes` without any `session.reset`/`resetByType` config, OpenClaw stays in idle-only mode for backward compatibility.\n- Per-type overrides (optional): `resetByType` lets you override the policy for `direct`, `group`, and `thread` sessions (thread = Slack/Discord threads, Telegram topics, Matrix threads when provided by the connector).\n- Per-channel overrides (optional): `resetByChannel` overrides the reset policy for a channel (applies to all session types for that channel and takes precedence over `reset`/`resetByType`).\n- Reset triggers: exact `/new` or `/reset` (plus any extras in `resetTriggers`) start a fresh session id and pass the remainder of the message through. `/new <model>` accepts a model alias, `provider/model`, or provider name (fuzzy match) to set the new session model. If `/new` or `/reset` is sent alone, OpenClaw runs a short “hello” greeting turn to confirm the reset.\n- Manual reset: delete specific keys from the store or remove the JSONL transcript; the next message recreates them.\n- Isolated cron jobs always mint a fresh `sessionId` per run (no idle reuse).",
    "Send policy (optional)": "Block delivery for specific session types without listing individual ids.\n\n\nRuntime override (owner only):\n\n- `/send on` → allow for this session\n- `/send off` → deny for this session\n- `/send inherit` → clear override and use config rules\n  Send these as standalone messages so they register.",
    "Configuration (optional rename example)": "",
    "Inspecting": "- `openclaw status` — shows store path and recent sessions.\n- `openclaw sessions --json` — dumps every entry (filter with `--active <minutes>`).\n- `openclaw gateway call sessions.list --params '{}'` — fetch sessions from the running gateway (use `--url`/`--token` for remote gateway access).\n- Send `/status` as a standalone message in chat to see whether the agent is reachable, how much of the session context is used, current thinking/verbose toggles, and when your WhatsApp web creds were last refreshed (helps spot relink needs).\n- Send `/context list` or `/context detail` to see what’s in the system prompt and injected workspace files (and the biggest context contributors).\n- Send `/stop` as a standalone message to abort the current run, clear queued followups for that session, and stop any sub-agent runs spawned from it (the reply includes the stopped count).\n- Send `/compact` (optional instructions) as a standalone message to summarize older context and free up window space. See [/concepts/compaction](/concepts/compaction).\n- JSONL transcripts can be opened directly to review full turns.",
    "Tips": "- Keep the primary key dedicated to 1:1 traffic; let groups keep their own keys.\n- When automating cleanup, delete individual keys instead of the whole store to preserve context elsewhere.",
    "Session origin metadata": "Each session entry records where it came from (best-effort) in `origin`:\n\n- `label`: human label (resolved from conversation label + group subject/channel)\n- `provider`: normalized channel id (including extensions)\n- `from`/`to`: raw routing ids from the inbound envelope\n- `accountId`: provider account id (when multi-account)\n- `threadId`: thread/topic id when the channel supports it\n  The origin fields are populated for direct messages, channels, and groups. If a\n  connector only updates delivery routing (for example, to keep a DM main session\n  fresh), it should still provide inbound context so the session keeps its\n  explainer metadata. Extensions can do this by sending `ConversationLabel`,\n  `GroupSubject`, `GroupChannel`, `GroupSpace`, and `SenderName` in the inbound\n  context and calling `recordSessionMetaFromInbound` (or passing the same context\n  to `updateLastRoute`)."
  },
  "commands": [],
  "code_blocks": [
    {
      "language": "json5",
      "content": "// ~/.openclaw/openclaw.json\n{\n  session: {\n    // Secure DM mode: isolate DM context per channel + sender.\n    dmScope: \"per-channel-peer\",\n  },\n}"
    },
    {
      "language": "json5",
      "content": "{\n  session: {\n    sendPolicy: {\n      rules: [\n        { action: \"deny\", match: { channel: \"discord\", chatType: \"group\" } },\n        { action: \"deny\", match: { keyPrefix: \"cron:\" } },\n      ],\n      default: \"allow\",\n    },\n  },\n}"
    },
    {
      "language": "json5",
      "content": "// ~/.openclaw/openclaw.json\n{\n  session: {\n    scope: \"per-sender\", // keep group keys separate\n    dmScope: \"main\", // DM continuity (set per-channel-peer/per-account-channel-peer for shared inboxes)\n    identityLinks: {\n      alice: [\"telegram:123456789\", \"discord:987654321012345678\"],\n    },\n    reset: {\n      // Defaults: mode=daily, atHour=4 (gateway host local time).\n      // If you also set idleMinutes, whichever expires first wins.\n      mode: \"daily\",\n      atHour: 4,\n      idleMinutes: 120,\n    },\n    resetByType: {\n      thread: { mode: \"daily\", atHour: 4 },\n      direct: { mode: \"idle\", idleMinutes: 240 },\n      group: { mode: \"idle\", idleMinutes: 120 },\n    },\n    resetByChannel: {\n      discord: { mode: \"idle\", idleMinutes: 10080 },\n    },\n    resetTriggers: [\"/new\", \"/reset\"],\n    store: \"~/.openclaw/agents/{agentId}/sessions/sessions.json\",\n    mainKey: \"main\",\n  },\n}"
    }
  ],
  "learned_from": "/usr/lib/node_modules/openclaw/docs/concepts/session.md",
  "source_type": "file",
  "name": "openclaw_session"
}